#include "mcl.h"

using namespace unavlib;

bool point_cmp(pcl::PointXYZ a, pcl::PointXYZ b){
    return a.z < b.z;
}

mcl::mcl()
{
    SetParam();
    // static ros::Subscriber feature_sub = m_nh.subscribe<jslocalization::feature>("/jslocalization_feature", 10, &mcl::feature_callback, this);
    static ros::Subscriber hdmap_pole_sub = m_nh.subscribe<jslocalization::poles>("/jslocalization/nodegen/pole_info", 10, &mcl::hdmap_pole_callback, this);
    static ros::Timer timer = m_nh.createTimer(ros::Duration(0.1), &mcl::timer_callback,this);

    static ros::Subscriber pole_sub = m_nh.subscribe<jslocalization::ObjTrackBoxes>("/jslocalization/sort/pole_tracked_boxes", 10, &mcl::pole_callback, this);


    m_pub_mclPose = m_nh.advertise<nav_msgs::Odometry>("jslocalization/mcl/pose",1);
    m_pub_mclParticles = m_nh.advertise<sensor_msgs::PointCloud2>("jslocalization/mcl/particles",1);
    m_pub_mclLiDAR = m_nh.advertise<sensor_msgs::PointCloud2>("jslocalization/mcl/lidar",1);
    m_pub_mclInfo = m_nh.advertise<jslocalization::mcl>("jslocalization/mcl/info",1);
    m_pub_markers = m_nh.advertise<visualization_msgs::MarkerArray>("jslocalization/sort/markers",1);


    result_pc_pub = m_nh.advertise<sensor_msgs::PointCloud2>("jslocalization/sort/pole_taracked_result",1);


    m_bestpose = Eigen::Matrix4f::Identity();

    map_received = false;
    first_run = true;

    pole_points_map.reset(new pcl::PointCloud<pcl::PointXYZ>());
    closest_points_scan.reset(new pcl::PointCloud<pcl::PointXYZ>());
}

void mcl::SetParam()
{    
    m_nh.param("/mcl/particle_min",m_param_particleMin,1000);
    m_nh.param("/mcl/particle_max",m_param_particleMax,10000);
    m_nh.param("/mcl/pole_max",m_param_pole_max,3);

    std::vector<double> covOdom;
    m_param_cov = Eigen::VectorXf(6);
    if(m_nh.getParam("/mcl/covariance_odom",covOdom))
    {
        if(covOdom.size() == 6)
        {
            m_param_cov[0] = covOdom[0];
            m_param_cov[1] = covOdom[1];
            m_param_cov[2] = covOdom[2];
            m_param_cov[3] = covOdom[3];
            m_param_cov[4] = covOdom[4];
            m_param_cov[5] = covOdom[5];
        }
    }

}

void mcl::timer_callback(const ros::TimerEvent& event)
{
    jslocalization::mcl mclInfo;
    mclInfo.lidar = cvt::cloud2msg(*closest_points_scan);
    mclInfo.mclPose.pose.pose = cvt::eigen2geoPose(m_bestpose);
    m_pub_mclInfo.publish(mclInfo);
}

// void mcl::pole_callback(const jslocalization::ObjTrackBoxes::ConstPtr &msg) 
// {   
//     std::cout << "[mcl] polecallback "<<msg->objlist.size()<<std::endl;
   
//     if (msg->objlist.size() == 0)
//         return;
//     else
//     {
//         visualization_msgs::MarkerArray bboxes;

//         pcl::PointCloud<pcl::PointXYZI>::Ptr pc_result (new pcl::PointCloud<pcl::PointXYZI>);
//         pcl::PointCloud<pcl::PointXYZI>::Ptr pc_result_tf (new pcl::PointCloud<pcl::PointXYZI>);
//         for(size_t i=0; i<msg->objlist.size(); i++)
//         {
//             pcl::PointXYZI obj;
//             obj.x = (msg->objlist[i].min_x + msg->objlist[i].max_x)/2;
//             obj.y = (msg->objlist[i].min_y + msg->objlist[i].max_y)/2;
//             obj.z = 0;
//             pc_result->points.push_back(obj);

//             visualization_msgs::Marker bbox;
//             bbox.header.frame_id = "odom";
//             bbox.header.stamp = ros::Time::now();
//             bbox.ns = "Detected Boundary";
//             bbox.id = 5000+i;
//             bbox.type = visualization_msgs::Marker::CUBE;
//             bbox.action = visualization_msgs::Marker::ADD;
//             bbox.lifetime = ros::Duration(0.1);

//             bbox.pose.orientation.w = 1.0;
//             bbox.pose.position.x = (msg->objlist[i].max_x + msg->objlist[i].min_x)/2.0;
//             bbox.pose.position.y = (msg->objlist[i].max_y + msg->objlist[i].min_y)/2.0;
//             bbox.pose.position.z = 5.0;
//             bbox.scale.x = msg->objlist[i].max_x - msg->objlist[i].min_x;
//             bbox.scale.y = msg->objlist[i].max_y - msg->objlist[i].min_y;
//             bbox.scale.z = 2.0;

//             bbox.color.r = 1.0;
//             bbox.color.g = 1.0;
//             bbox.color.b = 0.0;
//             bbox.color.a = 0.8;
//             bboxes.markers.push_back(bbox);
//         }

//         pcl::transformPointCloud(*pc_result, *pc_result_tf, cvt::geoPose2eigen(msg->gps_odom)); 
//         result_pc_pub.publish(unavlib::cvt::cloud2msg(*pc_result_tf, "odom"));

//         m_pub_markers.publish(bboxes);
//     }
// }

void mcl::pole_callback(const jslocalization::ObjTrackBoxes::ConstPtr &msg) 
{   
    if(!map_received)
        return;

    if(first_run)
    {   
        Eigen::Matrix4f pose = cvt::geoPose2eigen(msg->odom);
        Eigen::VectorXf pose_xyz = cvt::eigen2xyzrpy(pose);
        initParticle(cvt::geoPose2eigen(msg->odom),0.2); //2, 5
        std::cout<<"\033[1;34m[MCL]\033[0m callback initpose " << pose_xyz(0) << "," << pose_xyz(1) << "," << pose_xyz(5) * 180 / M_PI << std::endl;
        first_run = false;
    }
    
    closest_points_scan->points.clear();
    extract_closest_feature(*msg, *closest_points_scan);

    for(int i=0; i<closest_points_scan->points.size(); i++)
        std::cout<<closest_points_scan->points[i]<<std::endl;

    Eigen::Matrix4f crt_odom = cvt::geoPose2eigen(msg->odom); // lidar odometry!
    static Eigen::Matrix4f pre_odom = crt_odom;
    m_predictPose = pre_odom.inverse() * crt_odom;
    pre_odom = crt_odom;

    particle best_particle = spinOnce();

    Eigen::VectorXf bestPose_xyz = cvt::eigen2xyzrpy(best_particle.pose);

    std::cout<<"\033[1;34m[MCL]\033[0m "<<msg->index<<" th node / pose:" << bestPose_xyz(0) << "," << bestPose_xyz(1) << "," << bestPose_xyz(5) * 180 / M_PI << " /#: " << m_particles.size() << std::endl;

    // // //m_pub_mclInfo
    m_bestpose = best_particle.pose;
    jslocalization::mcl mclInfo;
    mclInfo.lidar = cvt::cloud2msg(*closest_points_scan);
    mclInfo.mclPose.pose.pose = cvt::eigen2geoPose(m_bestpose);
    m_pub_mclInfo.publish(mclInfo);

    // // publish
    pubparticle(best_particle);
    publidar(*closest_points_scan, cvt::geoPose2eigen(msg->gps_odom));//best_particle.pose);
    pubparticles(m_particles);
}

void mcl::objsPublisher(jslocalization::ObjTrackBoxes &msg)
{


}


// void mcl::feature_callback(const jslocalization::feature::ConstPtr &msg) 
// {
//     if(!map_received)
//         return;

//     if(first_run)
//     {   
//         Eigen::Matrix4f pose = cvt::geoPose2eigen(msg->odom);
//         Eigen::VectorXf pose_xyz = cvt::eigen2xyzrpy(pose);
//         initParticle(cvt::geoPose2eigen(msg->odom),0.2); //2, 5
//         std::cout<<"\033[1;34m[MCL]\033[0m callback initpose " << pose_xyz(0) << "," << pose_xyz(1) << "," << pose_xyz(5) * 180 / M_PI << std::endl;
//         first_run = false;
//     }
    
//     closest_points_scan->points.clear();
//     extract_closest_feature(msg->pole_obs, *closest_points_scan);

//     Eigen::Matrix4f crt_odom = cvt::geoPose2eigen(msg->odom); // lidar odometry!
//     static Eigen::Matrix4f pre_odom = crt_odom;
//     m_predictPose = pre_odom.inverse() * crt_odom;
//     pre_odom = crt_odom;

//     particle best_particle = spinOnce();

//     Eigen::VectorXf bestPose_xyz = cvt::eigen2xyzrpy(best_particle.pose);

//     std::cout<<"\033[1;34m[MCL]\033[0m "<<msg->index<<" th node / pose:" << bestPose_xyz(0) << "," << bestPose_xyz(1) << "," << bestPose_xyz(5) * 180 / M_PI << " /#: " << m_particles.size() << std::endl;

//     // // //m_pub_mclInfo
//     m_bestpose = best_particle.pose;
//     jslocalization::mcl mclInfo;
//     mclInfo.lidar = cvt::cloud2msg(*closest_points_scan);
//     mclInfo.mclPose.pose.pose = cvt::eigen2geoPose(m_bestpose);
//     m_pub_mclInfo.publish(mclInfo);

//     // // publish
//     pubparticle(best_particle);
//     publidar(*closest_points_scan, cvt::geoPose2eigen(msg->gps_odom));//best_particle.pose);
//     pubparticles(m_particles);
// }

void mcl::extract_closest_feature(jslocalization::ObjTrackBoxes poles, pcl::PointCloud<pcl::PointXYZ> &out_cloud)
{
    pcl::PointCloud<pcl::PointXYZ> pc_scan;
    pcl::PointCloud<pcl::PointXYZ> pc_scan_filtered;

    for(size_t i =0;i<poles.objlist.size();i++)
    {   
        pcl::PointXYZ temp;
        std::cout<<"["<<poles.objlist[i].min_x<<" "<<poles.objlist[i].min_y<<" "<<poles.objlist[i].max_x<<" "<<poles.objlist[i].max_y<<"]"<<std::endl;
        temp.x = (poles.objlist[i].min_x + poles.objlist[i].max_x)/2;
        temp.y = (poles.objlist[i].min_y + poles.objlist[i].max_y)/2;
        temp.z = sqrt(pow(temp.x,2)+pow(temp.y,2));
        pc_scan.points.push_back(temp);
    }  
    
    sort(pc_scan.points.begin(),pc_scan.end(),point_cmp); 


    int pole_max = 0;
    if(pc_scan.points.size() < m_param_pole_max && pc_scan.points.size() > 0)
    {
        pole_max = pc_scan.points.size();
    }
    else if(pc_scan.points.size() >= m_param_pole_max)
    {
        pole_max = m_param_pole_max;
    }
    else
    {
        std::cout<<"\033[1;34m[MCL]\033[0m\033[1;31m THERE IS NO POLE!\033[0m" << std::endl;
        out_cloud = pc_scan_filtered;
        return;
    }

    std::cout<<"\033[1;34m[MCL]\033[0m Total pole #: "<<poles.objlist.size()<<" sleected pole #: "<< pole_max<<std::endl;

    for(size_t i =0; i<pole_max; i++){
        pcl::PointXYZ temp;
        temp.x = pc_scan.points[i].x;
        temp.y = pc_scan.points[i].y;
        temp.z = 0;
        pc_scan_filtered.points.push_back(temp);
    }
    out_cloud = pc_scan_filtered;
}


// void mcl::extract_closest_feature(std::vector<geometry_msgs::Point> pole_obs, pcl::PointCloud<pcl::PointXYZ> &out_cloud)
// {
//     pcl::PointCloud<pcl::PointXYZ> pc_scan;
//     pcl::PointCloud<pcl::PointXYZ> pc_scan_filtered;

//     for(size_t i =0;i<pole_obs.size();i++)
//     {   
//         pcl::PointXYZ temp;
//         temp.x = pole_obs[i].x;
//         temp.y = pole_obs[i].y;
//         temp.z = sqrt(pow(temp.x,2)+pow(temp.y,2));
//         pc_scan.points.push_back(temp);
//     }  
    
//     sort(pc_scan.points.begin(),pc_scan.end(),point_cmp); 


//     int pole_max = 0;
//     if(pc_scan.points.size() < m_param_pole_max && pc_scan.points.size() > 0)
//     {
//         pole_max = pc_scan.points.size();
//     }
//     else if(pc_scan.points.size() >= m_param_pole_max)
//     {
//         pole_max = m_param_pole_max;
//     }
//     else
//     {
//         std::cout<<"\033[1;34m[MCL]\033[0m\033[1;31m THERE IS NO POLE!\033[0m" << std::endl;
//         out_cloud = pc_scan_filtered;
//         return;
//     }

//     std::cout<<"\033[1;34m[MCL]\033[0m Total pole #: "<<pole_obs.size()<<" sleected pole #: "<< pole_max<<std::endl;

//     for(size_t i =0; i<pole_max; i++){
//         pcl::PointXYZ temp;
//         temp.x = pc_scan.points[i].x;
//         temp.y = pc_scan.points[i].y;
//         temp.z = 0;
//         pc_scan_filtered.points.push_back(temp);
//     }
//     out_cloud = pc_scan_filtered;
// }

void mcl::hdmap_pole_callback(const jslocalization::poles::ConstPtr &map)
{
    if(!map_received){
        poles_map = *map;

        sensor_msgs::PointCloud2::Ptr cloud_in (new sensor_msgs::PointCloud2);
        pcl::PointCloud<pcl::PointXYZ>::Ptr pc_raw(new pcl::PointCloud<pcl::PointXYZ>);

        *cloud_in = map->pc_pole;
        pcl::fromROSMsg(*cloud_in, *pc_raw);
        *pole_points_map = *pc_raw;

        map_received = true;
        std::cout<<"\033[1;34m[MCL]\033[0m HDmap Pole data are received"<< std::endl;
    }
}


void mcl::find_nearest_point(pcl::PointCloud<pcl::PointXYZ>::Ptr in_cloud, pcl::PointXYZ in_point, pcl::PointXYZ &out_point, int &out_index, float &out_distance)
{
    pcl::KdTreeFLANN<pcl::PointXYZ> kdtree;
    kdtree.setInputCloud (in_cloud);
    std::vector<int> pointIdxNKNSearch(1);
    std::vector<float> pointNKNSquaredDistance(1);

    if ( kdtree.nearestKSearch (in_point, 1, pointIdxNKNSearch, pointNKNSquaredDistance) > 0 )
    {   
        for (std::size_t m = 0; m < pointIdxNKNSearch.size (); ++m)
        {
            out_point = (*in_cloud)[pointIdxNKNSearch[m]];
            out_index = pointIdxNKNSearch[m];
            out_distance = pointNKNSquaredDistance[m];
        }
    }
    else
    {
        out_point.x = 0;
        out_point.y = 0;
        out_point.z = 0;
        out_index = -1;
        out_distance = -1;
    }

}

particle mcl::spinOnce()
{
    m_particles = prediction(m_particles, m_predictPose); 

    weightning();  

    particle bestParticle = getBestParticle();

    resampling();

    return bestParticle;
}


void mcl::initParticle(Eigen::Matrix4f initpose, float boundary, float boundary_angle)
{
    Eigen::VectorXf pos_in = cvt::eigen2xyzrpy(initpose);

    std::cout<< "initpose: " << initpose<<std::endl;

    std::default_random_engine gen;
    std::uniform_real_distribution<double> x_pos(pos_in[0] - boundary, pos_in[0] + boundary);
    std::uniform_real_distribution<double> y_pos(pos_in[1] - boundary, pos_in[1] + boundary);
    std::uniform_real_distribution<double> theta_pos(pos_in[5] - boundary_angle * M_PI / 180, pos_in[5] + boundary_angle * M_PI / 180);
    m_particles.clear();
    for(int i=0;i<m_param_particleMax;i++)
    {
      particle particle_temp;
      particle_temp.pose = cvt::xyzrpy2eigen(x_pos(gen),y_pos(gen),0,0,0,theta_pos(gen));
      particle_temp.score = 1/(float)m_param_particleMax;
      m_particles.push_back(particle_temp);
    }
}


std::vector<particle> mcl::prediction(std::vector<particle> particles, Eigen::MatrixXf trans)
{   
    Eigen::VectorXf diff_xyzrpy = cvt::eigen2xyzrpy(trans);
    double delta_trans = sqrt(pow(diff_xyzrpy[0],2) + pow(diff_xyzrpy[1],2));
    double delta_rot1 = atan2(diff_xyzrpy[1], diff_xyzrpy[0]);
    if(delta_trans < 0.001)
        delta_rot1 = 0;
    double delta_rot2 = diff_xyzrpy[5] - delta_rot1;

    if(delta_rot1  > M_PI)
        delta_rot1 -= (2*M_PI);
    if(delta_rot1  < -M_PI)
        delta_rot1 += (2*M_PI);
    if(delta_rot2  > M_PI)
        delta_rot2 -= (2*M_PI);
    if(delta_rot2  < -M_PI)
        delta_rot2 += (2*M_PI);

    double delta_trans_err = m_param_cov[2] * abs(delta_trans) + m_param_cov[3] * abs(delta_rot1 + delta_rot2);
    double delta_rot1_err = m_param_cov[0] * abs(delta_rot1) + m_param_cov[1] * abs(delta_trans);
    double delta_rot2_err = m_param_cov[0] * abs(delta_rot2) + m_param_cov[1] * abs(delta_trans);

    for(size_t i=0;i<particles.size();i++)
    {
        double tilde_trans = delta_trans + probabilistic::GaussianRand() * delta_trans_err;
        double tilde_rot1 = delta_rot1 + probabilistic::GaussianRand() * delta_rot1_err;
        double tilde_rot2 = delta_rot2 + probabilistic::GaussianRand() * delta_rot2_err;

        double tmp_diff_x = tilde_trans * cos(tilde_rot1) + probabilistic::GaussianRand() * m_param_cov[4];
        double tmp_diff_y = tilde_trans * sin(tilde_rot1) + probabilistic::GaussianRand() * m_param_cov[4];
        double tmp_diff_theta = tilde_rot1 + tilde_rot2 + probabilistic::GaussianRand() * m_param_cov[5] * CV_PI / 180;

        particles.at(i).pose= particles.at(i).pose
                * cvt::xyzrpy2eigen(tmp_diff_x,tmp_diff_y,0, 0,0,tmp_diff_theta);
    }
    return particles;
}

void mcl::weightning()
{
    for(size_t i=0;i<m_particles.size();i++)
    {
        if(closest_points_scan->points.size()==0) // 확인 필요! 
            return;
        else
        {
            pcl::PointCloud<pcl::PointXYZ>::Ptr pole_transformed(new pcl::PointCloud<pcl::PointXYZ>);
            pcl::transformPointCloud(*closest_points_scan, *pole_transformed, m_particles.at(i).pose); 

            float weight = 0;

            for(size_t j=0;j<pole_transformed->points.size();j++)
            {   
                pcl::PointXYZ closest_point;
                int closest_index;
                float closest_dist;

                find_nearest_point(pole_points_map, pole_transformed->points[j], closest_point, closest_index, closest_dist);

                if(closest_dist <0 || closest_index <0 || sqrt(closest_dist)>  3.0)
                {
                    weight += 0;
                }
                else
                {   
                    weight += calcWeight(closest_dist, poles_map.pole[closest_index].covariance);
                }
                weight = weight / pole_transformed->points.size() + 0.00000000001;
            }

            m_particles.at(i).score = m_particles.at(i).score * weight;
        }
    } 
}

float mcl::calcWeight(float delta_dist, float covariance)
{
    return (float) exp(-delta_dist/(2*covariance)); 
}

void mcl::resampling()
{
    std::default_random_engine gen;

    float particles_sumscore = 0;
    for(int i=0;i<m_particles.size();i++)
    {
        particles_sumscore += m_particles.at(i).score;
    }
    std::vector<float> particles_scores;
    float normalized_scores = 0;
    for(size_t i=0;i<m_particles.size();i++){
      m_particles.at(i).score = m_particles.at(i).score / particles_sumscore; // This is for preventing specific particle to have too much score.
      normalized_scores += m_particles.at(i).score;
      particles_scores.push_back(normalized_scores);
    }
    std::uniform_real_distribution<double> dart(0, particles_scores.back());
    std::vector<particle> particles_sampled;
    int particleNum = adapted_quantity();
    for(size_t i=0;i<particleNum;i++)
    {
        bool particle_selected = false;
        while(!particle_selected)
        {
            double darted = dart(gen);
            for(size_t j=0;j<particles_scores.size();j++)
            {
                if(darted<particles_scores.at(j))
                {   
                    //is_onmap?
                    particles_sampled.push_back(m_particles.at(j));
                    particle_selected = true;
                    break;             
                }
            }
        }
    }
    m_particles = particles_sampled;
}

bool mcl::isOnmap(Eigen::MatrixXf pose)
{}

particle mcl::getBestParticle()
{
    particle max_particle;
    max_particle.score = std::numeric_limits<float>::min();

    for(int i=0;i<m_particles.size();i++)
    {
        if(m_particles.at(i).score > max_particle.score)
        {
            max_particle = m_particles.at(i);
        }
    }
    return max_particle;
}

int mcl::adapted_quantity()
{
    float max_x,max_y,min_x,min_y;
    max_x = std::numeric_limits<float>::min(); max_y = std::numeric_limits<float>::min();
    min_x = std::numeric_limits<float>::max(); min_y = std::numeric_limits<float>::max();
    for(size_t i=0;i<m_particles.size();i++)
    {
        Eigen::VectorXf pose_xyzrpy = cvt::eigen2xyzrpy(m_particles.at(i).pose);
        if(pose_xyzrpy[0]>max_x) max_x = pose_xyzrpy[0];
        if(pose_xyzrpy[0]<min_x) min_x = pose_xyzrpy[0];
        if(pose_xyzrpy[1]>max_y) max_y = pose_xyzrpy[1];
        if(pose_xyzrpy[1]<min_y) min_y = pose_xyzrpy[1];
    }
    
    if( (fabs(max_x-min_x)*fabs(max_y-min_y)*100) > m_param_particleMax ) 
    {
        return m_param_particleMax;
    }
    else if( (fabs(max_x-min_x)*fabs(max_y-min_y)*100) < (m_param_particleMin) )
    {
      return m_param_particleMin;  
    } 
    else{
        return ( fabs(max_x-min_x)*fabs(max_y-min_y)*100 );
    }
}

void mcl::pubparticle(particle particleo)
{
    nav_msgs::Odometry msg_particle;
    msg_particle.header.frame_id="odom";
    msg_particle.pose.pose = cvt::eigen2geoPose(particleo.pose);
    m_pub_mclPose.publish(msg_particle);
}

void mcl::pubparticles(std::vector<particle> particles)
{
    pcl::PointCloud<pcl::PointXYZ> particlePts;
    for(int i=0;i<particles.size();i++)
    {
        pcl::PointXYZ tmp_xyz;
        tmp_xyz.x = particles.at(i).pose(0,3);
        tmp_xyz.y = particles.at(i).pose(1,3);
        tmp_xyz.z = 0;
        particlePts.push_back(tmp_xyz);
    }

    m_pub_mclParticles.publish(cvt::cloud2msg(particlePts, "odom"));
}

void mcl::publidar(pcl::PointCloud<pcl::PointXYZ> lidar, Eigen::Matrix4f pose)
{
    pcl::PointCloud<pcl::PointXYZ> lidar_global;
    pcl::transformPointCloud(lidar,lidar_global,pose);
    sensor_msgs::PointCloud2 msg_lidar = cvt::cloud2msg(lidar_global);
    msg_lidar.header.frame_id="odom";
    m_pub_mclLiDAR.publish(msg_lidar);
}

