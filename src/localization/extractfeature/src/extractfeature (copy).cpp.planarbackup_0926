#include "extractfeature.h"

const int region_max_ = 8; // Change this value to match how far you want to detect.
int regions_[100];

bool point_cmp(pcl::PointXYZI a, pcl::PointXYZI b){
    return a.z<b.z;
}

feature::feature()
{
    static ros::Subscriber nodegen_sub = m_nh.subscribe<jsslam::node>("/jslocalization/feature/nodeIn", 10, &feature::pointCloudCallback, this);

    xy_clipped_pub_ =  m_nh.advertise<sensor_msgs::PointCloud2>("/jslocalization/feature/xy_clipped", 10);

    ground_pub = m_nh.advertise<sensor_msgs::PointCloud2>("/jslocalization/feature/ground", 1);
    non_ground_pub = m_nh.advertise<sensor_msgs::PointCloud2>("/jslocalization/feature/non_ground", 1);
    marking_pub = m_nh.advertise<sensor_msgs::PointCloud2>("/jslocalization/feature/road_marking", 1);

    po_z_clipped_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("po_z_clipped", 10);
    po_cluster_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("po_ec_cluster", 10);
    pole_frag_pub_ =  m_nh.advertise<sensor_msgs::PointCloud2>("pole_frag", 10);
    pole_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("pole", 10);

    pl_z_clipped_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("/jslocalization/feature/plane/z_clipped", 10);
    pl_cluster_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("/jslocalization/feature/plane/clusters", 10);
    plane_frag_pub_ =  m_nh.advertise<sensor_msgs::PointCloud2>("plane_frag", 10);
    plane_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("plane", 10);
    rg_plane_pub_ = m_nh.advertise<sensor_msgs::PointCloud2>("rg_plane", 10);


    jsslam_feature_pub_ = m_nh.advertise<jsslam::feature>("/jsslam_feature", 10);

    AllocateMemory();
    SetParam();
}

void feature::AllocateMemory()
{
    pc_pole.reset(new pcl::PointCloud<pcl::PointXYZI>());
    pc_plane.reset(new pcl::PointCloud<pcl::PointXYZI>());
    pc_marking.reset(new pcl::PointCloud<pcl::PointXYZI>());
    pc_nonground.reset(new pcl::PointCloud<pcl::PointXYZI>());
}

void feature::ResetParam()
{
    pc_pole->clear();
    pc_plane->clear();
    pc_marking->clear();
    pc_nonground->clear();
}

void feature::SetParam()
{   
    std::vector<double> lidar2body;
    if(m_nh.getParam("/NodeGen/lidar2body", lidar2body)) {
        if(lidar2body.size()==7) {
            geometry_msgs::Pose geo_pose;

            geo_pose.position.x = lidar2body[0];
            geo_pose.position.y = lidar2body[1];
            geo_pose.position.z = lidar2body[2];
            geo_pose.orientation.x = lidar2body[3];
            geo_pose.orientation.y = lidar2body[4];
            geo_pose.orientation.z = lidar2body[5];
            geo_pose.orientation.w = lidar2body[6];

            tf_lidar2body = unavlib::cvt::geoPose2eigen(geo_pose);
        }else {
            ROS_ERROR("TF MUST BE X,Y,Z,Qx,Qy,Qw,Qz");
            exit(0);
        }
    }

    m_nh.param<std::string>("/System/model", sensor_model_, "os1-64"); // VLP-16, HDL-32E, HDL-64E

    m_nh.param("/ground/sensor_height", sensor_height_, 2.0);
    m_nh.param("/ground/removal_height", removal_height_, 1.5);
    m_nh.param("/ground/num_seg", num_seg_, 1);
    m_nh.param("/ground/num_iter", num_iter_, 3);
    m_nh.param("/ground/num_lpr", num_lpr_, 20);
    m_nh.param("/ground/th_seeds", th_seeds_, 1.2);
    m_nh.param("/ground/th_dist", th_dist_, 0.3);

    m_nh.param("/road/max_intensity", max_intensity, 1000.0);
    m_nh.param("/road/min_intensity", min_intensity, 500.0);
    
    m_nh.param<float>("/pole/z_axis_min", po_z_axis_min_, -1.0);
    m_nh.param<float>("/pole/z_axis_max", po_z_axis_max_, 10.0);
    m_nh.param<int>("/pole/cluster_size_min", po_cluster_size_min_, 5);
    m_nh.param<int>("/pole/cluster_size_max", po_cluster_size_max_, 700000);
    m_nh.param<float>("/pole/height_pole", po_height, 2.5);
    m_nh.param<float>("/pole/height_max", po_height_max, 2.5);
    m_nh.param<float>("/pole/height_min", po_height_min, 1.0);
    m_nh.param<float>("/pole/voxel_size", po_voxel_size, 0.2);
    m_nh.param<float>("/pole/pole_radius", po_radius, 3.0);
    m_nh.param<float>("/pole/ec_tolerance", po_ec_tolerance, 0.2);
    m_nh.param<float>("/pole/height_trunk", po_trunk_height, 0.5);

    m_nh.param<float>("/planar/z_axis_min", pl_z_axis_min_, -1.0);
    m_nh.param<float>("/planar/z_axis_max", pl_z_axis_max_, 10.0);
    m_nh.param<int>("/planar/cluster_size_min", pl_cluster_size_min_, 5);
    m_nh.param<int>("/planar/cluster_size_max", pl_cluster_size_max_, 700000);
    m_nh.param<float>("/planar/height_plane", pl_height, 2.5);
    m_nh.param<float>("/planar/height_max", pl_height_max, 2.5);
    m_nh.param<float>("/planar/height_min", pl_height_min, 1.0);
    m_nh.param<float>("/planar/ratio_plane", pl_ratio, 0.85);
    m_nh.param<float>("/planar/distance_plane", pl_distance, 2.0);
    m_nh.param<int>("/planar/num_normal_kd", num_normal_kd, 100);
    m_nh.param<float>("/planar/normal_weight", normal_weight, 0.5);
    //region growing 
    m_nh.param<int>("/planar/rg_num_ksearch",rg_num_ksearch,5);
    m_nh.param<int>("/planar/rg_mincluster",rg_mincluster,5);
    m_nh.param<int>("/planar/rg_numneighbor",rg_numneighbor,5);
    m_nh.param<float>("/planar/rg_smoothness",rg_smoothness,5);
    m_nh.param<float>("/planar/rg_curvature",rg_curvature,5);


    if (sensor_model_ == "os1-64") { // if ec tolerance is 0.1
        regions_[0] = 11; regions_[1] = 11; regions_[2] = 11; regions_[3] = 11; regions_[4] = 11;
        regions_[5] = 11; regions_[6] = 11; regions_[7] = 11; 
    }

    // if (sensor_model_ == "os1-64") { // if ec tolerance is 0.2
    //     regions_[0] = 22; regions_[1] = 22; regions_[2] = 22; regions_[3] = 22; regions_[4] = 22;
    //     regions_[5] = 22; regions_[6] = 22; regions_[7] = 22; 
    // }
    std::cout<< "[ground parameters] num_lpr: "<<num_lpr_<<" th_seeds: "<<th_seeds_<<" th_dist: "<<th_dist_<<std::endl;
}

void feature::pointCloudCallback(const jsslam::node::ConstPtr &node)
{
    sensor_msgs::PointCloud2::Ptr cloudmsg_in (new sensor_msgs::PointCloud2);
    pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_pc_raw(new pcl::PointCloud<pcl::PointXYZI>);

    *cloudmsg_in = node->lidar;
    pcl::fromROSMsg(*cloudmsg_in, *pcl_pc_raw);

    pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_pc_clipped_x(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr pcl_pc_in(new pcl::PointCloud<pcl::PointXYZI>);

    RemoveSideX(pcl_pc_raw, *pcl_pc_clipped_x, 50.0);
    RemoveSideY(pcl_pc_clipped_x, *pcl_pc_in, 50.0);
    xy_clipped_pub_.publish(unavlib::cvt::cloud2msg(*pcl_pc_in, "map"));

    RoadPlaneExtration(pcl_pc_in);  //pcl_pc_in

    pcl::PointCloud<pcl::PointXYZI>::Ptr no_plane_in(new pcl::PointCloud<pcl::PointXYZI>);

    std::clock_t start = std::clock();
    ExtractPlaneObject(pcl_pc_in,*no_plane_in); // pcl_pc_in
    // ExtractPoleObject(no_plane_in);
    std::clock_t end = std::clock();
    std::cout << "Running Time of Feature Extraction: " << static_cast<double>((end-start))/CLOCKS_PER_SEC << std::endl;
    
    // pcl::PointCloud<pcl::PointXYZI>::Ptr pole_transformed (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr pole_transformed2 (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr plane_transformed (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr plane_transformed2 (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr marking_transformed (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr marking_transformed2 (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr nonground_transformed (new pcl::PointCloud<pcl::PointXYZI>);
    // pcl::PointCloud<pcl::PointXYZI>::Ptr nonground_transformed2 (new pcl::PointCloud<pcl::PointXYZI>);


    // pcl::transformPointCloud(*pc_plane, *plane_transformed2, tf_lidar2body);  
    // pcl::transformPointCloud(*plane_transformed2, *plane_transformed, unavlib::cvt::geoPose2eigen(nodegen->gps_pose));

    // pcl::transformPointCloud(*pc_pole, *pole_transformed2, tf_lidar2body );
    // pcl::transformPointCloud(*pole_transformed2, *pole_transformed, unavlib::cvt::geoPose2eigen(nodegen->gps_pose));

    // pcl::transformPointCloud(*pc_marking, *marking_transformed2, tf_lidar2body);
    // pcl::transformPointCloud(*marking_transformed2, *marking_transformed, unavlib::cvt::geoPose2eigen(nodegen->gps_pose));

    // pcl::transformPointCloud(*pc_nonground, *nonground_transformed2, tf_lidar2body);
    // pcl::transformPointCloud(*nonground_transformed2, *nonground_transformed, unavlib::cvt::geoPose2eigen(nodegen->gps_pose));

    // jsslam_feature.header.frame_id = "odom";
    // jsslam_feature.header.stamp = nodegen->header.stamp;
    // jsslam_feature.node_index = nodegen->node_index;
    // jsslam_feature.gps_pose = nodegen->gps_pose;
    // jsslam_feature.lidar_global = nodegen->lidar_global;
    // jsslam_feature.lidar_local = nodegen->lidar_local;
    // jsslam_feature.pole_object = unavlib::cvt::cloud2msg(*pole_transformed, "odom");
    // jsslam_feature.plane_object = unavlib::cvt::cloud2msg(*plane_transformed, "odom");
    // jsslam_feature.marking_object = unavlib::cvt::cloud2msg(*marking_transformed, "odom");
    // jsslam_feature.nonground_global = unavlib::cvt::cloud2msg(*nonground_transformed, "odom");
    // jsslam_feature.nonground_local = unavlib::cvt::cloud2msg(*nonground_transformed2, "odom");
    // jsslam_feature_pub_.publish(jsslam_feature);

    // std::cout << "Feature Index: " << nodegen->node_index << std::endl;

    // ResetParam();
}




void feature::ExtractPlaneObject(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud, pcl::PointCloud<pcl::PointXYZI> &out_cloud)
{
    pcl::IndicesPtr pc_indices(new std::vector<int>);
    pcl::PassThrough<pcl::PointXYZI> pt;
    pt.setInputCloud(in_cloud);
    pt.setFilterFieldName("z");
    pt.setFilterLimits(pl_z_axis_min_, pl_z_axis_max_);
    pt.filter(*pc_indices);

    pcl::PointCloud<pcl::PointXYZI>::Ptr z_clipped(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::copyPointCloud(*in_cloud, *pc_indices, *z_clipped);
    pl_z_clipped_pub_.publish(unavlib::cvt::cloud2msg(*z_clipped, "map"));

    boost::array<std::vector<int>, region_max_> indices_array;
    for(int i = 0; i <  pc_indices->size(); i++){
        float range = 0.0;
        for(int j = 0; j < region_max_; j++){
            float d2 = in_cloud->points[(*pc_indices)[i]].x * in_cloud->points[(*pc_indices)[i]].x +
                     in_cloud->points[(*pc_indices)[i]].y * in_cloud->points[(*pc_indices)[i]].y +
                     in_cloud->points[(*pc_indices)[i]].z * in_cloud->points[(*pc_indices)[i]].z;
            if(d2 > range * range && d2 <= (range + regions_[j]) * (range + regions_[j])) {
                indices_array[j].push_back((*pc_indices)[i]);
                break;
            }
            range += regions_[j];
        }
    }

    float tolerance = 0.0;
    std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr>> clusters;
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);

    for(int i = 0; i < region_max_; i++) {
        tolerance += 0.1;
        if(indices_array[i].size() > pl_cluster_size_min_) {
            boost::shared_ptr<std::vector<int> > indices_array_ptr(new std::vector<int>(indices_array[i]));
            pcl::search::KdTree<pcl::PointXYZI>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZI>);
            tree->setInputCloud(in_cloud, indices_array_ptr);

            std::vector<pcl::PointIndices> cluster_indices;
            pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;
            ec.setClusterTolerance(tolerance);
            ec.setMinClusterSize(pl_cluster_size_min_);
            ec.setMaxClusterSize(pl_cluster_size_max_);
            ec.setSearchMethod(tree);
            ec.setInputCloud(in_cloud);
            ec.setIndices(indices_array_ptr);
            ec.extract(cluster_indices);

      
            for(std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin(); it != cluster_indices.end(); it++) {
                pcl::PointCloud<pcl::PointXYZI>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZI>);
                for(std::vector<int>::const_iterator pit = it->indices.begin(); pit != it->indices.end(); ++pit) {
                    cluster->points.push_back(in_cloud->points[*pit]);
                    inliers->indices.push_back(*pit);
                }
                cluster->width = cluster->size();
                cluster->height = 1;
                cluster->is_dense = true;
                clusters.push_back(cluster);

            }        
        }
    }

    pcl::PointCloud<pcl::PointXYZI>::Ptr pc_cluster(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr pc_cluster_filtered(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr pc_test(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr rg_planar_ptr (new pcl::PointCloud<pcl::PointXYZI>);


    // std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr>> clusters_filtered;
    // std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr>> clusters_filtered2;

    for(int i = 0; i < clusters.size(); i++) {
        *pc_cluster += *clusters[i];
        pcl::PointXYZI cluster_min, cluster_max;
        pcl::getMinMax3D(*clusters[i], cluster_min, cluster_max);

        if( abs(cluster_max.z - cluster_min.z) > pl_height && abs(cluster_min.z - pl_z_axis_min_) < pl_height_min)  // 나무, 바닥 등을 걸러주기 위함 
        {
            *pc_cluster_filtered += *clusters[i];
            // clusters_filtered.push_back(clusters[i]);
          // Eigen::Vector4f xyz_centroid;
          // pcl::compute3DCentroid (*clusters[i], xyz_centroid);
          // Eigen::Matrix3f covariance_matrix;
          // pcl::computeCovarianceMatrix (*clusters[i], xyz_centroid, covariance_matrix);   
          // std::cout << "covariance_matrix" << std::endl << covariance_matrix << std::endl;

            pcl::PointCloud<pcl::PointXYZI>::Ptr ptr_voxel(new pcl::PointCloud<pcl::PointXYZI>);
            voxelize(clusters[i], *ptr_voxel, 0.2, 0.2, 0.2);

            std::vector<pcl::PointIndices> rg_clusters;
            region_growing(ptr_voxel, rg_clusters);

            pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_f (new pcl::PointCloud<pcl::PointXYZI>);

            for(int i=0; i<rg_clusters.size(); i++)
            {
                std::cout <<i<<"th cluster size : " << rg_clusters[i].indices.size() <<std::endl;
                pcl::PointIndices::Ptr planar_inliers(new pcl::PointIndices());
                *planar_inliers = rg_clusters[i];
                pcl::copyPointCloud(*ptr_voxel, *planar_inliers, *cloud_f);
                *rg_planar_ptr += *cloud_f ;
            }
            
            // pcl::PointCloud<pcl::PointXYZI>::Ptr pc_planar_candidates (new pcl::PointCloud<pcl::PointXYZI>);
            // // RansacNormalPlanar(clusters[i], *pc_planar_candidates);
            // RansacNormalPlanar(ptr_voxel, *pc_planar_candidates);
            // *pc_test += *pc_planar_candidates;

            // pcl::PointXYZI plane_min, plane_max;
            // pcl::getMinMax3D(*pc_planar_candidates, plane_min, plane_max);

            // if((plane_max.x-plane_min.x)*(plane_max.x-plane_min.x) + (plane_max.y-plane_min.y)*(plane_max.z-plane_min.z) > pl_distance*pl_distance){
            //     Eigen::Vector4f xyz_centroid;
            //     pcl::compute3DCentroid (*pc_planar_candidates, xyz_centroid);
            //     plane_cluster_centroid.push_back(xyz_centroid);
            //     // clusters_filtered2.push_back(pc_planar_candidates);
            //     *pc_plane = *pc_planar_candidates;
            // }

        }
    }

    rg_plane_pub_.publish(unavlib::cvt::cloud2msg(*rg_planar_ptr, "map"));

    pl_cluster_pub_.publish(unavlib::cvt::cloud2msg(*pc_cluster, "map"));

    // pcl::PointCloud<pcl::PointXYZI>::Ptr pc_filtered_cluster(new pcl::PointCloud<pcl::PointXYZI>);
    // for(int i = 0; i < clusters_filtered.size(); i++) {
    //     *pc_filtered_cluster += *clusters_filtered[i];
    // }
    // plane_frag_pub_.publish(unavlib::cvt::cloud2msg(*pc_filtered_cluster, "odom"));

    // pcl::PointCloud<pcl::PointXYZI>::Ptr pc_filtered_cluster2(new pcl::PointCloud<pcl::PointXYZI>);
    // for(int i = 0; i < clusters_filtered2.size(); i++) {
    //     *pc_filtered_cluster2 += *clusters_filtered2[i];
    // }
    // plane_pub_.publish(unavlib::cvt::cloud2msg(*pc_filtered_cluster2, "odom"));

    plane_frag_pub_.publish(unavlib::cvt::cloud2msg(*pc_cluster_filtered, "map"));
    // plane_pub_.publish(unavlib::cvt::cloud2msg(*pc_plane, "map"));
    plane_pub_.publish(unavlib::cvt::cloud2msg(*pc_test, "map"));


}

void feature::voxelize(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud, pcl::PointCloud<pcl::PointXYZI> &out_cloud, double leaf_x, double leaf_y, double leaf_z)
{

    pcl::VoxelGrid<pcl::PointXYZI> voxel_filter;

    pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_cloud(new pcl::PointCloud<pcl::PointXYZI>());

    voxel_filter.setInputCloud(in_cloud);
    voxel_filter.setLeafSize(leaf_x,leaf_y,leaf_z);
    voxel_filter.filter(*filtered_cloud);

    out_cloud = *filtered_cloud;
}

void feature::ExtractPoleObject(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud)
{
    /*** Remove ground and ceiling ***/
    pcl::IndicesPtr pc_indices(new std::vector<int>);
    pcl::PassThrough<pcl::PointXYZI> pt;
    pt.setInputCloud(in_cloud);
    pt.setFilterFieldName("z");
    pt.setFilterLimits(po_z_axis_min_, po_z_axis_max_);
    pt.filter(*pc_indices);

    pcl::PointCloud<pcl::PointXYZI>::Ptr z_clipped(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::copyPointCloud(*in_cloud, *pc_indices, *z_clipped);
    po_z_clipped_pub_.publish(unavlib::cvt::cloud2msg(*z_clipped, "odom"));

    /*** Divide the point cloud into nested circular regions ***/
    boost::array<std::vector<int>, region_max_> indices_array;
    for(int i = 0; i < pc_indices->size(); i++) {
        float range = 0.0;
        for(int j = 0; j < region_max_; j++) {
          float d2 = in_cloud->points[(*pc_indices)[i]].x * in_cloud->points[(*pc_indices)[i]].x +
                     in_cloud->points[(*pc_indices)[i]].y * in_cloud->points[(*pc_indices)[i]].y +
                     in_cloud->points[(*pc_indices)[i]].z * in_cloud->points[(*pc_indices)[i]].z;
          if(d2 > range * range && d2 <= (range+regions_[j]) * (range+regions_[j])) {
            indices_array[j].push_back((*pc_indices)[i]);
            break;
          }
          range += regions_[j];
        }
    }

    /*** Euclidean clustering ***/
    float tolerance = 0.0;
    std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr>> clusters;

    for(int i = 0; i < region_max_; i++) {
        tolerance += 0.1;
        if(indices_array[i].size() > po_cluster_size_min_) {
            boost::shared_ptr<std::vector<int> > indices_array_ptr(new std::vector<int>(indices_array[i]));
            pcl::search::KdTree<pcl::PointXYZI>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZI>);
            tree->setInputCloud(in_cloud, indices_array_ptr);

            std::vector<pcl::PointIndices> cluster_indices;
            pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec;
            ec.setClusterTolerance(tolerance);
            ec.setMinClusterSize(po_cluster_size_min_);
            ec.setMaxClusterSize(po_cluster_size_max_);
            ec.setSearchMethod(tree);
            ec.setInputCloud(in_cloud);
            ec.setIndices(indices_array_ptr);
            ec.extract(cluster_indices);
          
            for(std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin(); it != cluster_indices.end(); it++) {
                pcl::PointCloud<pcl::PointXYZI>::Ptr cluster(new pcl::PointCloud<pcl::PointXYZI>);
                for(std::vector<int>::const_iterator pit = it->indices.begin(); pit != it->indices.end(); ++pit) {
                    cluster->points.push_back(in_cloud->points[*pit]);
                }
                cluster->width = cluster->size();
                cluster->height = 1;
                cluster->is_dense = true;
                clusters.push_back(cluster);
            }
        }
    }

    pcl::PointCloud<pcl::PointXYZI>::Ptr pc_cluster(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr pc_pole_cluster(new pcl::PointCloud<pcl::PointXYZI>);


    std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr > > clusters_filtered;
    std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr > > clusters_voxelized;
    std::vector<pcl::PointCloud<pcl::PointXYZI>::Ptr, Eigen::aligned_allocator<pcl::PointCloud<pcl::PointXYZI>::Ptr > > clusters_eliminated;

    for(int i = 0; i < clusters.size(); i++) {
       *pc_cluster += *clusters[i];

        pcl::PointXYZI cluster_min, cluster_max;
        pcl::getMinMax3D(*clusters[i], cluster_min, cluster_max);

        if( abs(cluster_max.z - cluster_min.z) > po_height && abs(cluster_max.z - cluster_min.z) < po_height_max && abs(cluster_min.z - po_z_axis_min_) < po_height_min) 
        {
            // clusters_filtered.push_back(clusters[i]);   
            unsigned int num_slice =  (int) (abs(cluster_max.z - cluster_min.z)/po_voxel_size) + 1 ;

            for(int j = 0; j < num_slice; j++)
            {
                pcl::PointCloud<pcl::PointXYZI>::Ptr pc_height_slice (new pcl::PointCloud<pcl::PointXYZI>);

                double clip_min = (double) (cluster_min.z + po_voxel_size*(j));
                double clip_max = (double) (cluster_min.z + po_voxel_size*(j+1));

                ClipHeight(clusters[i], *pc_height_slice, clip_min, clip_max);
                // clusters_voxelized.push_back(pc_height_slice);

                pcl::PointXYZI slice_min, slice_max;
                pcl::getMinMax3D(*pc_height_slice, slice_min, slice_max);

                if((slice_min.x-slice_max.x)*(slice_min.x-slice_max.x) + (slice_min.y-slice_max.y)*(slice_min.y-slice_max.y) < 4*po_radius*po_radius)
                {
                    // clusters_eliminated.push_back(pc_height_slice);
                    *pc_pole_cluster += *pc_height_slice;
                }
            }
        }

    }

    po_cluster_pub_.publish(unavlib::cvt::cloud2msg(*pc_cluster, "odom"));

    // pcl::PointCloud<pcl::PointXYZI>::Ptr pc_pole_cluster(new pcl::PointCloud<pcl::PointXYZI>);
    // for(int i = 0; i < clusters_eliminated.size(); i++) {
    //     *pc_pole_cluster += *clusters_eliminated[i];
    // }
    // pole_frag_pub_.publish(unavlib::cvt::cloud2msg(*pc_pole_cluster, "odom"));
    pole_frag_pub_.publish(unavlib::cvt::cloud2msg(*pc_pole_cluster, "odom"));

    // pcl::PointCloud<pcl::PointXYZI>::Ptr pole_candidates(new pcl::PointCloud<pcl::PointXYZI>);
    pcl::search::KdTree<pcl::PointXYZI>::Ptr tree_new(new pcl::search::KdTree<pcl::PointXYZI>);
    tree_new->setInputCloud(pc_pole_cluster);

    std::vector<pcl::PointIndices> cluster_indices_new;
    pcl::EuclideanClusterExtraction<pcl::PointXYZI> ec_new;
    ec_new.setClusterTolerance(po_ec_tolerance);
    ec_new.setMinClusterSize(po_cluster_size_min_);
    ec_new.setMaxClusterSize(po_cluster_size_max_);
    ec_new.setSearchMethod(tree_new);
    ec_new.setInputCloud(pc_pole_cluster);
    ec_new.extract(cluster_indices_new);

    for(std::vector<pcl::PointIndices>::const_iterator it = cluster_indices_new.begin(); it != cluster_indices_new.end(); it++) {
        pcl::PointCloud<pcl::PointXYZI>::Ptr cluster_new(new pcl::PointCloud<pcl::PointXYZI>);
        for(std::vector<int>::const_iterator pit = it->indices.begin(); pit != it->indices.end(); ++pit) {
            cluster_new->points.push_back(pc_pole_cluster->points[*pit]);
        }
        cluster_new->width = cluster_new->size();
        cluster_new->height = 1;
        cluster_new->is_dense = true;
        // clusters.push_back(cluster);
        pcl::PointXYZI trunk_min, trunk_max;
        pcl::getMinMax3D(*cluster_new, trunk_min, trunk_max);
        if(trunk_max.z - trunk_min.z > po_trunk_height){
            // *pole_candidates += *cluster_new;
            *pc_pole += *cluster_new;
        }
    }

    // pole_pub_.publish(unavlib::cvt::cloud2msg(*pole_candidates, "odom"));
    pole_pub_.publish(unavlib::cvt::cloud2msg(*pc_pole, "odom"));
}

void feature::RemoveSideX(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud, pcl::PointCloud<pcl::PointXYZI> &out_cloud, double max_range)
{
    static pcl::PassThrough<pcl::PointXYZI> pass_remove;

    pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_cloud (new pcl::PointCloud<pcl::PointXYZI>);

    pass_remove.setInputCloud(in_cloud);
    pass_remove.setFilterFieldName("x");
    pass_remove.setFilterLimits(-max_range, max_range);

    pass_remove.filter(*filtered_cloud);

    out_cloud = *filtered_cloud;
}

void feature::RemoveSideY(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud, pcl::PointCloud<pcl::PointXYZI> &out_cloud, double max_range)
{
    static pcl::PassThrough<pcl::PointXYZI> pass_remove;

    pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_cloud (new pcl::PointCloud<pcl::PointXYZI>);

    pass_remove.setInputCloud(in_cloud);
    pass_remove.setFilterFieldName("y");
    pass_remove.setFilterLimits(-max_range, max_range);

    pass_remove.filter(*filtered_cloud);

    out_cloud = *filtered_cloud;
}

void feature::ClipHeight(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud, pcl::PointCloud<pcl::PointXYZI> &out_cloud, double min_height, double max_height)
{
    static pcl::PassThrough<pcl::PointXYZI> pass_height;

    pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_cloud (new pcl::PointCloud<pcl::PointXYZI>);

    pass_height.setInputCloud(in_cloud);
    pass_height.setFilterFieldName("z");
    pass_height.setFilterLimits(min_height, max_height);

    pass_height.filter(*filtered_cloud);

    out_cloud = *filtered_cloud;
}

void feature::RansacNormalPlanar(pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_in, pcl::PointCloud<pcl::PointXYZI>& dst)
{
    pcl::PointCloud<pcl::Normal>::Ptr cloud_normals (new pcl::PointCloud<pcl::Normal>);
    pcl::ModelCoefficients::Ptr coefficients_plane (new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers_plane (new pcl::PointIndices);

    pcl::search::KdTree<pcl::PointXYZI>::Ptr kdtree(new pcl::search::KdTree<pcl::PointXYZI>);
    // pcl::KdTreeFLANN<pcl::PointXYZI>::Ptr kdtree (new pcl::KdTreeFLANN<pcl::PointXYZI>);

    // Estimate point normals
    pcl::NormalEstimation<pcl::PointXYZI, pcl::Normal> ne;
    ne.setSearchMethod (kdtree);
    ne.setInputCloud (cloud_in);
    ne.setKSearch (num_normal_kd); // num_normal_kd 100
    ne.compute (*cloud_normals);

    pcl::SACSegmentationFromNormals<pcl::PointXYZI, pcl::Normal> seg;
    // Create the segmentation object for the planar model and set all the parameters
    seg.setOptimizeCoefficients (true);
    seg.setModelType (pcl::SACMODEL_NORMAL_PLANE);
    seg.setNormalDistanceWeight (normal_weight); //0.5
    seg.setMethodType (pcl::SAC_RANSAC);
    seg.setMaxIterations (100);
    seg.setDistanceThreshold (0.1);
    seg.setInputCloud (cloud_in);
    seg.setInputNormals (cloud_normals);

    // Obtain the plane inliers and coefficients
    seg.segment (*inliers_plane, *coefficients_plane);
    // std::cerr << "Plane coefficients: " << *coefficients_plane << std::endl;

    pcl::ExtractIndices<pcl::PointXYZI> extract;
    // Extract the planar inliers from the input cloud
    extract.setInputCloud (cloud_in);
    extract.setIndices (inliers_plane);
    extract.setNegative (false);

    // Write the planar inliers to disk
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud_plane (new pcl::PointCloud<pcl::PointXYZI>);
    extract.filter (*cloud_plane);
    // ROS_INFO ("PointCloud representing the planar component: %zu data points.", cloud_plane->points.size ());

    dst = *cloud_plane;

}

void feature::region_growing(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud, std::vector<pcl::PointIndices> &out_cluster)
{
    // std::cout<<"\033[1;36m[RegionGrowing]\033[0m Region growing is started "<< std::endl;
    std::clock_t start = std::clock();

    pcl::search::Search<pcl::PointXYZI>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZI>);
    pcl::PointCloud <pcl::Normal>::Ptr normals (new pcl::PointCloud <pcl::Normal>);
    pcl::NormalEstimation<pcl::PointXYZI, pcl::Normal> normal_estimator;
    normal_estimator.setSearchMethod (tree);
    normal_estimator.setInputCloud (in_cloud);
    normal_estimator.setKSearch (rg_num_ksearch);
    normal_estimator.compute (*normals);

    pcl::RegionGrowing<pcl::PointXYZI, pcl::Normal> reg;
    reg.setMinClusterSize (rg_mincluster);
    reg.setMaxClusterSize (100000);
    reg.setSearchMethod (tree);
    reg.setNumberOfNeighbours (rg_numneighbor);
    reg.setInputCloud (in_cloud);
    //reg.setIndices (indices);
    reg.setInputNormals (normals);
    reg.setSmoothnessThreshold (rg_smoothness / 180.0 * M_PI); //3.0
    reg.setCurvatureThreshold (rg_curvature); // 1.0 

    std::vector <pcl::PointIndices> clusters;
    reg.extract (clusters);

    out_cluster = clusters;

    std::clock_t end = std::clock();
    std::cout<<"\033[1;36m[RegionGrowing]\033[0m Running Time : " << static_cast<double>((end-start))/CLOCKS_PER_SEC << std::endl;

    // pcl::PointCloud <pcl::PointXYZRGB>::Ptr colored_cloud = reg.getColoredCloud ();
    // pcl::visualization::CloudViewer viewer ("Cluster viewer");
    // viewer.showCloud(colored_cloud);
    // while (!viewer.wasStopped ())
    // {
    // }

}

// void PoleObject::RoadPlaneExtration(const sensor_msgs::PointCloud2::ConstPtr &lidar)
void feature::RoadPlaneExtration(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud)
{    
    pcl::PointCloud<pcl::PointXYZI>::Ptr g_seeds_pc (new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr g_ground_pc (new pcl::PointCloud<pcl::PointXYZI>);
    pcl::PointCloud<pcl::PointXYZI>::Ptr g_not_ground_pc (new pcl::PointCloud<pcl::PointXYZI>);

    pcl::PointCloud<pcl::PointXYZI> laserCloudIn;
    pcl::PointCloud<pcl::PointXYZI> laserCloudIn_org;

    laserCloudIn = *in_cloud;
    laserCloudIn_org = *in_cloud;

    // 2. Sort on Z-axis value.
    sort(laserCloudIn.points.begin(),laserCloudIn.end(),point_cmp); 

    // 3.Error point removal
    // As there are some error mirror reflection under the ground, 
    // here regardless point under 2* sensor_height
    // Sort point according to height, here uses z-axis in default
    pcl::PointCloud<pcl::PointXYZI>::iterator it = laserCloudIn.points.begin();
    for(int i=0;i<laserCloudIn.points.size();i++){
        if(laserCloudIn.points[i].z < -removal_height_*sensor_height_){
            it++;
        }else{
            break;
        }
    }
    laserCloudIn.points.erase(laserCloudIn.points.begin(),it);

    ExtractInitialSeeds(laserCloudIn, *g_seeds_pc);
    g_ground_pc = g_seeds_pc;

    for(int i=0;i<num_iter_;i++){
        EstimatePlane(g_seeds_pc);
        g_ground_pc->clear();
        g_not_ground_pc->clear();

        //pointcloud to matrix
        MatrixXf points(laserCloudIn_org.points.size(),3);
        int j =0;
        for(auto p:laserCloudIn_org.points){
            points.row(j++)<<p.x,p.y,p.z;
        }
        // ground plane model
        VectorXf result = points*normal_;
        // threshold filter
        for(int r=0;r<result.rows();r++){
            if(result[r]<th_dist_d_){
                g_ground_pc->points.push_back(laserCloudIn_org[r]);
            }else{
                g_not_ground_pc->points.push_back(laserCloudIn_org[r]);
            }
        }
    }

    for(int i=0; i<g_ground_pc->points.size(); i++)
    {
        if(g_ground_pc->points[i].intensity > min_intensity && g_ground_pc->points[i].intensity < max_intensity )
            pc_marking->points.push_back(g_ground_pc->points[i]);
    }

    *pc_nonground = *g_not_ground_pc;

    ground_pub.publish(unavlib::cvt::cloud2msg(*g_ground_pc, "map"));
    non_ground_pub.publish(unavlib::cvt::cloud2msg(*pc_nonground, "map"));
    marking_pub.publish(unavlib::cvt::cloud2msg(*pc_marking, "map"));
}


void feature::EstimatePlane(pcl::PointCloud<pcl::PointXYZI>::Ptr in_cloud){
    // Create covarian matrix in single pass.
    // TODO: compare the efficiency.
    Eigen::Matrix3f cov;
    Eigen::Vector4f pc_mean;
    pcl::computeMeanAndCovarianceMatrix(*in_cloud, cov, pc_mean);
    // Singular Value Decomposition: SVD
    // Used in JacobiSVD to indicate that the square matrix U is to be computed. 
    JacobiSVD<MatrixXf> svd(cov,Eigen::DecompositionOptions::ComputeFullU); 
    // use the least singular vector as normal
    normal_ = (svd.matrixU().col(2));
    // std::cout << "normal value : " << normal_ << std::endl;
    // mean ground seeds value
    Eigen::Vector3f seeds_mean = pc_mean.head<3>();

    // according to normal.T*[x,y,z] = -d
    d_ = -(normal_.transpose()*seeds_mean)(0,0);
    // set distance threhold to `th_dist - d`
    th_dist_d_ = th_dist_ - d_;
 
    // return the equation parameters
}

void feature::ExtractInitialSeeds(const pcl::PointCloud<pcl::PointXYZI>& p_sorted, pcl::PointCloud<pcl::PointXYZI> &out_cloud){
    // LPR is the mean of low point representative
    pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_cloud (new pcl::PointCloud<pcl::PointXYZI>);

    double sum = 0;
    int cnt = 0;
    // Calculate the mean height value.
    for(int i=0;i<p_sorted.points.size() && cnt<num_lpr_;i++){
        sum += p_sorted.points[i].z;
        cnt++;
    }
    double lpr_height = cnt!=0?sum/cnt:0;// in case divide by 0
    filtered_cloud->clear();
    // iterate pointcloud, filter those height is less than lpr.height+th_seeds_
    for(int i=0;i<p_sorted.points.size();i++){
        if(p_sorted.points[i].z < lpr_height + th_seeds_){
            filtered_cloud->points.push_back(p_sorted.points[i]);
        }
    }
    out_cloud = *filtered_cloud;
    // return seeds points
}